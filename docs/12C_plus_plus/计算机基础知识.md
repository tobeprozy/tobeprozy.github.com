---
title: 计算机重要知识

article: true
date: 2023-04-14
category:
  - C plus
tag:
  - 算法
  - C plus
order: 
icon: 🧑
---

::: tip
计算机重要知识

:::

# 计算机重要知识

Created: September 15, 2022 8:35 AM

### 进制计算

**1、二进制转十进制：**

> 例如二进制的：101001转换过程：1*2^0+0*2^1+0*2^2+1*2^3+0*2^4+1*2^5=1+8+32=41结果：41
> 

**2、十进制转二进制：**

> 用辗转法将十进制转换成二进制：例如十进制的：41
> 
> 
> 41/2=20---1,
> 
> 20/2=10---0,
> 
> 10/2=5----0,
> 
> 5/2  =2----1,
> 
> 2/2  =2----0,
> 
> 1/2  =1----1;
> 
> 二进制的结果（自下向上组合）：101001
> 

3、**十进制转十六进制：**

> 第一步先十进制转成二进制，第二步再二进制转16进制例如：
45第一步十进制转成二进制：
45/2=22...1
> 
> 
> 22/2=11...0
> 11/2=5.....1
> 5/2=2.......1
> 2/2=1.......0
> 1/2=1.......1
> 二进制为：101101
> 检验结果是否正确：1*2^0+1*2^2+1*2^3+1*2^5=1+4+8+32=45
> 
> 第二步二进制转16进制:
> 10 1101
> 十六进制得出最终结果为：2D
> 

.4、**十六进制转十进制：**

> 十六进制：2AF(F)
15*16^0+(A)10*16^1+2*16^2=15+160+512=687
故此：687
> 

5、**二进制转十六进制：**

> 四个一位 不够前面补0：例如100010
> 
> 
> 0010 0010
> 2       2 
> 十六进制等于：22
> 

6、**十六进制转二进制：**

> 右至左
22故此：100010
> 
> 
> CE
> C        E       (C=12,E=14 )
> 1100   1110 
> 二进制结果为：11001110
> 

7、**八进制转十六进制：**

> 第一步先八进制转成二进制，第二步再二进制转16进制
例如 24第一步：二进制（三位一个自右到左分隔）：10 100   得到：10100第二步：16进制（四位一个自右到左分隔）：1 0100
> 
> 
> 十六进制为：14
> 

8、**十六进制转八进制：**

> 步骤：1.十六进制先转成二进制 二进制再转八进制 （自右向左三位一个）
例如：2AF第一步           
2   A        F          
10 1010  1111
> 
> 
> 第二步
> 
> (00)1 010 101 111
> 
> 1      2     5    7
> 
> 八进制结果为：1257
> 

9、**二进制转八进制(取三合一法，即从二进制的小数点为分界点，向左（向右）每三位取成一位)**

> 将二进制数101110.101转换为八进制
101    110    101
5         6        5
> 
> 
> 得到结果：56.5
> 

10、**八进制转二进制（八进制的数字是0~7，大于7的不符合八进制的要求，逢八进一）：**

> 例如八进制的 7.11
7     1     1
111 001 001一位变成三位
二进制结果为：111.001001
> 

### 补码计算：

*[计算机存储的是原码*、反码、*还是补码*?](https://www.baidu.com/link?url=2zCVQ2cjUejJrzc0AXkeS6GLw4DGxkZ4KH7xEe15AF2EWty_ku4kIELKF3LQ3dlMRSb6Z3kvG0NB9g0bpc7LVq&wd=&eqid=c3bee9020026874f00000003632277f0)**补码**

**原码的求解规则：**

正数：就是它对应的二进制数。

负数：将绝对值对应的二进制最左边位变为1。

所以-11的原码就是**1**0001011。

备注：最左边是符号位，0表示正数，1表示负数，下同。

**反码的求解规则：**

正数：和原码相同，也就是对应的二进制数。

负数：将原码符号位之外的数字取反，即0变1，1为0。

所以-11的反码是**1**1110100

**补码的求解规则：**

正数：和反码相同，也就是对应的二进制数。

负数：将反码的最后一位加1。

所以-11的补码就是**1**111010**1**

知识要点：

1、十进制转二进制是根本

2、8位表示，最左边0代表正，1代表负

3、正数原、反、补相同

4、从原到反再到补，逐步求解不要乱

### 重载、重写、隐藏

1、重载指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同。

2、重写指的是在派生类中覆盖基类中的同名函数，**重写就是重写函数体**，**要求基类函数必须是虚函数**且：

- 与基类的虚函数有相同的参数个数
- 与基类的虚函数有相同的参数类型
- 与基类的虚函数有相同的返回值类型

3、隐藏：

- 两个函数参数相同，但是基类函数不是虚函数。此时隐藏和重写的区别在于基类函数是否是虚函数
- **两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中**

### c++中.和->和::和:的区别

```cpp
A.B,则A为对象或者结构体；

A->B,则A为指针，->是成员提取，A->B是提取A中的成员B，A只能是指向类、结构、联合的指针；

::是作用域运算符，A::B表示作用域A中的名称B，A可以是名字空间、类、结构；

:一般用来表示继承；
```

<aside>
🪁 一般情况下用“.”，只需要声明一个结构体。格式是，结构体类型名+结构体名。然后用结构体名加“.”加域名就可以引用域 了。因为自动分配了结构体的内存。如同 int a;一样。
而用“->”，则要声明一个结构体的指针，还要手动开辟一个该结构体的内存，然后把返回的指针给声明的结构体指针，才能用“->”正确引用。否则内存中只分配了指针的内存，没有分配结构体的内存，导致想要的结构体实际上是不存在。这时候用“->”引用自然出错了，因为没有结构体，自然没有结构体的域了。

</aside>

### c++类中的构造函数

```cpp
class Student{
public:
    Student(){//默认构造函数，没有参数
        this->age = 20;
        this->num = 1000;
    };  
    Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数和参数列表
    Student(const Student& s){//拷贝构造函数，这里与编译器生成的一致
        this->age = s.age;
        this->num = s.num;
    }; 

  //定义了一个赋值构造函数
	Student& operator=(const Student& stu);
    Student(int r){   //转换构造函数,形参是其他类型变量，且只有一个形参
        this->age = r;
		this->num = 1002;
    };
    ~Student(){}
public:
    int age;
    int num;
};
```

- **默认构造函数和初始化构造函数**在定义类的对象，完成对象的初始化工作
- **复制构造函数用于复制本类的对象**
- **转换构造函数用于将其他类型的变量**，隐式转换为本类对象

### 深拷贝和浅拷贝

**浅拷贝**

浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。

**深拷贝**

深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。